use serde_derive::Deserialize;
use crate::blueprints::*;

#[derive(Debug, Deserialize)]
pub struct GitRepo {
    branch: Option<String>,
    #[serde(default)]
    ssh: bool, // default is false
    #[serde(default = "GitRepo::default_suffix")]
    suffix: String,
    #[serde(default = "GitRepo::default_ignore")]
    ignore: TemplateFile,
}

impl GitRepo {
    pub fn default_suffix() -> String {
        ".jl".to_string()
    }

    pub fn default_ignore() -> TemplateFile {
        TemplateFile::from_str("./.gitignore.hbs")
    }
}

impl Blueprint for GitRepo {
    fn collect(&self, ctx: &mut Context) -> RenderResult {
        let branch = match &self.branch {
            Some(b) => b.to_owned(),
            None => "main".to_string(),
        };

        let user = &*ctx.git.as_ref().unwrap().user;
        let package = &*ctx.project.name;
        let repo = package.to_string() + &self.suffix;

        let remote = if self.ssh {
            format!("git@github.com:{}/{}.git", user, repo).to_string()
        } else {
            format!("https:://github.com/{}/{}.git", user, repo).to_string()
        };
        let url = format!("https://github.com/{}/{}", user, repo).to_string();

        ctx.repository = Some(context::Repository {
            url,
            remote,
            branch,
        });
        Ok(())
    }

    // 1. git init
    // 2. git remote add origin
    // if default branch (main, usually) is not <branch>
    // 3. git checkout -b <branch>
    // 4. git branch -D main
    // 5. git branch -m <branch>
    fn render(&self, ctx: &Context) -> RenderResult {
        self.ignore.render(ctx, ".gitignore")?;
        let repository = ctx.repository.as_ref().unwrap();
        let remote = &repository.remote;
        let branch = &repository.branch;

        std::process::Command::new("git")
            .arg("init").output().expect("git init failed");

        if let Some(current_branch) = git_current_branch() {
            if &current_branch != branch {
                git_checkout(&branch)?;
                git_delete_branch(&current_branch)?;
                std::process::Command::new("git")
                    .arg("branch").arg("-m").arg(&branch)
                    .output().expect("git branch -m failed");
            }
        } else {
            git_checkout(&branch)?;
        }

        std::process::Command::new("git")
            .arg("remote").arg("add").arg("origin")
            .arg(remote).output().expect("git remote add failed");
        Ok(())
    }

    // 1. git add -A
    fn post_render(&self, _ctx: &Context) -> RenderResult {
        std::process::Command::new("git")
            .arg("add").arg("-A").output().expect("git add -A failed");
        std::process::Command::new("git")
            .arg("commit").arg("-m").arg("files generated by ion")
            .output().expect("git commit failed");
        Ok(())
    }
}
